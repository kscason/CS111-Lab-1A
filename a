200 lines for 1A.

No starting code :c Completely test alone... ew.

Parse options, perform work for each option.

--pipe will have a subprocess (childrensssss)

Need a file descriptor table: 0-5.... each FD has a number that points to a file. Think of it as a name for the file. 
     0 isn't the file descriptor really, just an index.
     Dynamically allocated array.

--pipe gives two file descriptors, read then write.

--verbose : print out the option to be executed
	  Only starts printing AFTER the option
	  ie.
	  $ ./simpsh --cmd... --klolkj --verbose --no --yes
	  For first two options, verbose turned off (don't print a thing).
	  Last two you do need to print.

Need unistd.h for getopt()
     Using only long options (aka --)
     3 Basic Variables:
       int opterr.optopt
       int optind
       char* optarg


int main( int argc, char** argv)
{
   \\we pass in cat a.txt

}



struct option holds:
       const char *name
       int has.arg : no_argument, required_argument, option_argument
       int *flag : 0 if none,
       int val

int execvp(const char *file, char *const argv[]);
       execvp("cat", INPUT NECESSARY);

pid_t fork() will create an identical child process
      in child, will return 0

To execute cat command, you'll have to stick this in a child process.
First create a child process, have it execute the subcommand cat.

dup2 will fix the file descriptor table.

int dup2( int old, int new );
    this way if you start with 6 you can change it to 0 or 1 or whatever.
    

--command i o e
	  --command 1 0 6
  	  file descriptor 1 goes to input, file descriptor 0 to output, file descriptor 6 to error
	  Remember file descriptor is not the same.

Keep track of number of files you open. Dyamically allocate. 
     Store each int value in an arrary.
     Figure out dup2 and why you need it for this allocation thing for command.

"rdonly", required_argument, 0, RDONLY
"wronly", .... , WRONLY
"command", ????
"verbose", no_argument, ???



ret = getopt.long()?
   
switch(ret){
	case RDONLY:
	     ...
	     pid child.pid = fork();
	     if(child.pid == 0 )
	     	  execup(?,?)

	     else if(???)	
	     	  ?????


dup2( )
  


So command has more than one argument after it so... optarg only points to the first one. optind points to next index (the second arg)
   Use optind to use the string from argv()
   If you find a -- bad... there are only --! 
   Once done pass the command to execup.
